<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>

    /*
    
      [ 자료형 (Data Type): 변수에 저장되는 값의 종류 ]

      1. 원시형 자료 (primitive type)
        - 해당 변수에 바로 값이 대입되어 있는 형태
        - 값이 callstack에 저장된다.
        - 변수에 원시형 자료가 담겨있을 때 해당 변수값을 복사하면 값 자체가 복사됨 
          (deep copy: 깊은 복사 - 물리적으로 복사)
        - 변수에 해당 값만 할당

        < 종류 >
        - 문자열 (string)
        - 숫자 (number)
        - 불리언 (boolean)
        - undefined (undefined)

      2. 참조형 자료 (reference type / object type)
        - 해당 변수에 바로 값이 대입되는 것이 아닌 원래 값이 있는 위치의 참조 주소가 대입되어 있는 형태
        - 값이 Heap 메모리에 저장되어 있고 Heap 메모리에 있는 위치링크(참조값)이 변수에 저장되는 형태
        - 변수에 참조형 자료가 담겨있을 때 해당 변수값을 복사하면 값 자체가 복사되는 것이 아닌 참조링크만 복사됨 
          (shallow copy: 얕은 복사)
        - 변수에 해당 값만 참조되는 것이 아닌 해당 자료형에서 사용할 수 있는 내장 메서드들도 같이 참조됨

        < 종류 >
        - 배열 (object)
        - 객체 (object)
        - null (object)
    
    */

    // 문자열
    let txt = 'Hello';

    // 숫자
    let num = 3;

    // 불리언 (true, false)
    let isFemale = true;

    // undefined: 변수 선언 후 값을 할당하지 않았을 때 자동으로 들어가는 자료형
    let err;

    // 배열: 규칙성이 있는 여러개의 자료들을 그룹화할 때
    let colors = ['red', 'green', 'blue'];

    // 객체: 여러개의 자료값을 그룹화할 때 해당 값을 key: value 형태로 구조화한 형태
    let studentA = {
      name: 'David',
      age: 20,
      isFemale: false
    }

    // null: undefined처럼 의도치 않게 값이 비어있는 것이 아닌 일부러 값을 비워둘 때 사용
    let empty = null;


    /*
    
      [ 얕은 복사 ]
      참조형 자료는 변수값을 새로운 변수에 옮겨담아 복사할 때 얕은 복사가 이루어진다.
      얕은복사가 되면 원본은 그대로 있는 상태에서 해당 원본을 참조하는 참조링크만 2개로 복사가 된다.
      새로 복사한 배열의 변수값을 변경하면 그 변수에 담겨 있는 참조링크가 지칭하는 값이 동일하기 때문에
      원본을 훼손하게 된다. (불변성유지 안됨)
    
    */

    let oldArray = [1, 2, 3];
    let newArray = oldArray;

    newArray[0] = 0;

    console.log('newArray: ', newArray);
    console.log('oldArray: ', oldArray);


    /*
      [ 자료형 검사하기 ]
      - 실제 null의 자료형은 null이지만 object로 찍히는 이유는 자바스크립트의 버그
    */

    const name = 'David';
    const age = 20;
    const isMale = true;
    const errors = undefined;
    const colors2 = ['red', 'green', 'blue'];
    const obj = {
      name: 'Emily',
      age: 20
    }
    const empty2 = null;

    console.log(typeof name);
    console.log(typeof age);
    console.log(typeof isMale);
    console.log(typeof errors);
    console.log(typeof colors2);
    console.log(typeof obj);
    console.log(typeof empty2);

  </script>
</body>

</html>